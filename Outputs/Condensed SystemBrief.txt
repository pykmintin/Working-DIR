### 2.1 Advisor The Advisor is a **conversational input designer** for other agents. Core responsibilities: - Talk with the user in natural language. - Help the user clarify goals, constraints, and intentions. - Read and interpret documents like this snapshot. - Convert messy or high-level ideas into **structured briefs** for other agents. The Advisor: - does not design workflows or experiments directly, - does not apply learning objectives as rigid rules, - focuses on **what to ask for**, not how the next agent must perform the task. The Advisor always: - routes this snapshot and other artifacts, - decides what to surface to which agent, - frames tasks with clear goals but open methods. ### 3.1 learning.json — Knowledge Pack for Agents - JSON file containing **condensed learning objectives**. - Built from earlier reports and model outputs. - Contains: - metadata (version, generated date, purpose), - a list of short learning objective statements, - notes for future refinement. What it is: - A **knowledge pack** meant to be given to agents (especially Meta-Architect instances) so they can reason with richer conceptual tools. - It does **not** define the system architecture. - It encodes **ideas and principles** we want agents to consider. ### 3.4 MetaArchetect.txt — Meta-Architect Role Description - Prose document describing the Meta-Architect role and its environment. - Emphasizes: - operating downstream of an Advisor, - treating work as multi-phase transformations, - branching and exploring alternatives, - performing sanity checks and optimization, - working within a manually orchestrated, log-rich environment. Purpose now: - Provides a **deep conceptual picture** of what "Meta-Architect" can be. - Serves as a reference when defining or refining Meta-Architect prompts and behaviors. ## 4. Learning Objectives (High-Level Summary) The learning objectives in learning.json are **not** the system design; they are knowledge we want agents to use. At a high level, they cover themes such as: - treating prompts as assets with lifecycle management and observability, - using defense-in-depth and context separation to reduce prompt injection and drift, - separating generation from synthesis and using multiple candidates/models, - designing with verification burden in mind (human attention is scarce), - mapping model strengths empirically rather than by assumption, - building four-layer architectures (shielding, routing, critique, semantic knowledge bases), - using manual actions and tagging as strong verification and feedback signals, - minimizing cognitive overhead to keep verification reliable. Agents that consume learning.json should treat its contents as **considerations and tools**, not as rigid rules. --- ## 5. Prompt Design Philosophy (What vs. How) A core principle in this system is: > Prompts should focus on **what to do**, not **how to do it**. This principle is **especially important for Advisors**, who are responsible for: - framing tasks for Meta-Architect and other agents, - clearly stating goals, available context, and constraints, - avoiding premature narrowing of methods or internal steps. Guidelines for Advisors: - Define **what** the agent should aim to accomplish. - Describe **which artifacts and knowledge** are available (e.g., logs, learning.json, blueprint excerpts). - Avoid prescribing **how** the agent must structure its reasoning or phases. - Treat non-certain ideas as **considerations**, not requirements. - Keep the method-space open enough for high-capability agents to propose better strategies. Guidelines for Meta-Architect (as implied context, not direct instruction): - Meta-Architect instances are expected to **synthesize insights**, optimize processes, and design or audit prompts. - They must balance: - when to keep options open and explore multiple lines of thought, - when to narrow attention and focus on a specific strategy, - when a multi-step process is necessary to reach a reliable outcome. - The Meta-Architect should be free to choose its own internal methods, as long as they respect the goals and environment described by the Advisor. This philosophy exists to preserve flexibility, avoid over-constraining agents, and allow them to fully exploit Kimi K2’s capabilities. I want full design of how to incorporate as much of and most effectively right now to initialize an advisor and meta_architects system_prompt master